Through the command line tool provided by snarkjs, we can easily generate and verify zero-knowledge proofs.
Below we briefly introduce how to use the snarkjs command line tool to generate and verify zero-knowledge proofs in stages.

# 1.Generate public and private parameters

The pot14_final.ptau file contains the common parameters of the circuit. We can change the curve, snarkjs supports bn128, and bls12-381.

```
snarkjs powersoftau new bn128 14 pot14_0000.ptau -v //14 means the maximum number of constraints supported by the circuit is 2^14
snarkjs powersoftau contribute pot14_0000.ptau pot14_0001.ptau --name="First contribution" -v
snarkjs powersoftau contribute pot14_0001.ptau pot14_0002.ptau --name="Second contribution" -v -e="some random text"
snarkjs powersoftau export challenge pot14_0002.ptau challenge_0003
snarkjs powersoftau challenge contribute bn128 challenge_0003 response_0003 -e="some random text"
snarkjs powersoftau import response pot14_0002.ptau response_0003 pot14_0003.ptau -n="Third contribution name"
snarkjs powersoftau verify pot14_0003.ptau
snarkjs powersoftau beacon pot14_0003.ptau pot14_beacon.ptau 0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f 10 -n="Final Beacon"
snarkjs powersoftau prepare phase2 pot14_beacon.ptau pot14_final.ptau -v
snarkjs powersoftau verify pot14_final.ptau
```


```
circom --r1cs --wasm --c --sym --inspect cubic_expression.circom
```

This command takes the circom file as input and generates the r1cs constraint file and wasm file

snarkjs supports three zkp types: groth16, plonk, and fflonk. Groth16 requires a trusted ceremony for each circuit. You need to repeat the above steps to generate the final.zkey. For plonk and fflonk, you only need the following step（take plonk as an example）:

```
snarkjs plonk setup circuit.r1cs pot14_final.ptau circuit_final.zkey
```

This command takes the r1cs constraint generated by compiling the circom file as input and generates the circuit_final key file;


# 2. Calculate Witness

Before creating any proofs, we need to compute all circuit signals that match (all) the circuit constraints. These signals are the "witnesses".
First, create a ```input.json``` file:
For example:

```
{
"x": 3
}
```

Run the command to calculate the witness

```
snarkjs wtns calculate circuit.wasm input.json witness.wtns
```

This command uses the wasm file and input.json file generated by compiling the circom file as input to generate the witness.wtns file;

# 3. Key Check

```
snarkjs zkey verify circuit.r1cs pot14_final.ptau circuit_final.zkey
```

This command takes the circuit.r1cs constraint file, pot14_final.ptau public parameters and circuit_final.zkey key file as input to verify the correctness of the key;

# 4. Key export

```
snarkjs zkey export verificationkey circuit_final.zkey verification_key.json
```

After verifying the key, convert circuit_final.zkey to verification_key.json in json format;

# 5. Generate Proof

```
snarkjs plonk prove circuit_final.zkey witness.wtns proof.json public.json
```

This command takes the circuit_final.zkey key and witness.wtns as input to generate proof.json and public.json files;
The proof.json file is the actual proof file; the public.json file contains the public input and output;

# 6. Verification Proof

```
snarkjs plonk verify verification_key.json public.json proof.json
```

After receiving the verification_key.json, public.json and proof.json files, output the verification result of proof.
